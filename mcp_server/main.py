# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:55:29+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, HTTPBearer

from models import (
    Account,
    AccountRequest,
    AccountsGetResponse,
    AccountsGetResponse1,
    AccountsGetResponse2,
    AccountsGetResponse3,
    AccountsIdDeleteResponse,
    AccountsIdDeleteResponse1,
    AccountsIdDeleteResponse2,
    AccountsIdGetResponse,
    AccountsIdGetResponse1,
    AccountsIdGetResponse2,
    AccountsIdPatchResponse,
    AccountsIdPatchResponse1,
    AccountsIdPatchResponse2,
    AccountsIdPatchResponse3,
    AccountsIdPutResponse,
    AccountsIdPutResponse1,
    AccountsIdPutResponse2,
    AccountsIdPutResponse3,
    AccountsPostResponse,
    AccountsPostResponse1,
    AccountsPostResponse2,
    AccountUpdate,
    AccountUpdatePartial,
    AuthRefreshPostResponse,
    AuthRefreshPostResponse1,
    AuthToken,
    AuthTokenPostResponse,
    AuthTokenPostResponse1,
    AuthTokenRequest,
    CancellationPolicy,
    CancellationRequest,
    Connection,
    ConnectionsGetResponse,
    ConnectionsGetResponse1,
    ConnectionsGetResponse2,
    ConnectionsGetResponse3,
    ConnectionsIdGetResponse,
    ConnectionsIdGetResponse1,
    ConnectionsIdGetResponse2,
    Contact,
    ContactRequest,
    ContactRequestPartial,
    ContactsGetResponse,
    ContactsGetResponse1,
    ContactsGetResponse2,
    ContactsGetResponse3,
    ContactsIdDeleteResponse,
    ContactsIdDeleteResponse1,
    ContactsIdDeleteResponse2,
    ContactsIdDeleteResponse3,
    ContactsIdGetResponse,
    ContactsIdGetResponse1,
    ContactsIdGetResponse2,
    ContactsIdPatchResponse,
    ContactsIdPatchResponse1,
    ContactsIdPatchResponse2,
    ContactsIdPatchResponse3,
    ContactsIdPutResponse,
    ContactsIdPutResponse1,
    ContactsIdPutResponse2,
    ContactsIdPutResponse3,
    ContactsPostResponse,
    ContactsPostResponse1,
    ContactsPostResponse2,
    DeliveryMethod,
    Device,
    DevicesGetResponse,
    DevicesGetResponse1,
    DevicesGetResponse2,
    DevicesGetResponse3,
    DevicesIdGetResponse,
    DevicesIdGetResponse1,
    DevicesIdGetResponse2,
    DowngradeAllowed,
    FacilitiesGetResponse,
    FacilitiesGetResponse1,
    FacilitiesGetResponse2,
    FacilitiesGetResponse3,
    FacilitiesIdGetResponse,
    FacilitiesIdGetResponse1,
    FacilitiesIdGetResponse2,
    FacilitiesIdGetResponse3,
    HealthResponse,
    Id,
    ImplementationResponse,
    IpAddress,
    IpAddressRequest,
    IpAddressUpdate,
    IpAddressUpdatePartial,
    IpsGetResponse,
    IpsGetResponse1,
    IpsGetResponse2,
    IpsGetResponse3,
    IpsIdGetResponse,
    IpsIdGetResponse1,
    IpsIdGetResponse2,
    IpsIdPatchResponse,
    IpsIdPatchResponse1,
    IpsIdPatchResponse2,
    IpsIdPatchResponse3,
    IpsIdPutResponse,
    IpsIdPutResponse1,
    IpsIdPutResponse2,
    IpsIdPutResponse3,
    MacAddress,
    MacAddressRequest,
    MacsGetResponse,
    MacsGetResponse1,
    MacsGetResponse2,
    MacsGetResponse3,
    MacsIdDeleteResponse,
    MacsIdDeleteResponse1,
    MacsIdDeleteResponse2,
    MacsIdDeleteResponse3,
    MacsIdGetResponse,
    MacsIdGetResponse1,
    MacsIdGetResponse2,
    MacsPostResponse,
    MacsPostResponse1,
    MacsPostResponse2,
    MemberJoiningRule,
    MemberJoiningRuleRequest,
    MemberJoiningRulesGetResponse,
    MemberJoiningRulesGetResponse1,
    MemberJoiningRulesGetResponse2,
    MemberJoiningRulesGetResponse3,
    MemberJoiningRulesIdDeleteResponse,
    MemberJoiningRulesIdDeleteResponse1,
    MemberJoiningRulesIdDeleteResponse2,
    MemberJoiningRulesIdDeleteResponse3,
    MemberJoiningRulesIdGetResponse,
    MemberJoiningRulesIdGetResponse1,
    MemberJoiningRulesIdGetResponse2,
    MemberJoiningRulesIdPatchResponse,
    MemberJoiningRulesIdPatchResponse1,
    MemberJoiningRulesIdPatchResponse2,
    MemberJoiningRulesIdPatchResponse3,
    MemberJoiningRulesIdPutResponse,
    MemberJoiningRulesIdPutResponse1,
    MemberJoiningRulesIdPutResponse2,
    MemberJoiningRulesIdPutResponse3,
    MemberJoiningRulesPostResponse,
    MemberJoiningRulesPostResponse1,
    MemberJoiningRulesPostResponse2,
    MemberJoiningRuleUpdate,
    MemberJoiningRuleUpdatePartial,
    MetroAreaNetwork,
    MetroAreaNetworksGetResponse,
    MetroAreaNetworksGetResponse1,
    MetroAreaNetworksGetResponse2,
    MetroAreaNetworksGetResponse3,
    MetroAreaNetworksIdGetResponse,
    MetroAreaNetworksIdGetResponse1,
    MetroAreaNetworksIdGetResponse2,
    MetroAreasGetResponse,
    MetroAreasGetResponse1,
    MetroAreasGetResponse2,
    MetroAreasGetResponse3,
    MetroAreasIdGetResponse,
    MetroAreasIdGetResponse1,
    MetroAreasIdGetResponse2,
    MetroAreasIdGetResponse3,
    NetworkFeature,
    NetworkFeatureConfig,
    NetworkFeatureConfigRequest,
    NetworkFeatureConfigsGetResponse,
    NetworkFeatureConfigsGetResponse1,
    NetworkFeatureConfigsGetResponse2,
    NetworkFeatureConfigsGetResponse3,
    NetworkFeatureConfigsIdDeleteResponse,
    NetworkFeatureConfigsIdDeleteResponse1,
    NetworkFeatureConfigsIdDeleteResponse2,
    NetworkFeatureConfigsIdDeleteResponse3,
    NetworkFeatureConfigsIdGetResponse,
    NetworkFeatureConfigsIdGetResponse1,
    NetworkFeatureConfigsIdGetResponse2,
    NetworkFeatureConfigsIdPatchResponse,
    NetworkFeatureConfigsIdPatchResponse1,
    NetworkFeatureConfigsIdPatchResponse2,
    NetworkFeatureConfigsIdPatchResponse3,
    NetworkFeatureConfigsIdPutResponse,
    NetworkFeatureConfigsIdPutResponse1,
    NetworkFeatureConfigsIdPutResponse2,
    NetworkFeatureConfigsIdPutResponse3,
    NetworkFeatureConfigsPostResponse,
    NetworkFeatureConfigsPostResponse1,
    NetworkFeatureConfigsPostResponse2,
    NetworkFeatureConfigUpdate,
    NetworkFeatureConfigUpdatePartial,
    NetworkFeaturesGetResponse,
    NetworkFeaturesGetResponse1,
    NetworkFeaturesGetResponse2,
    NetworkFeaturesGetResponse3,
    NetworkFeaturesIdGetResponse,
    NetworkFeaturesIdGetResponse1,
    NetworkFeaturesIdGetResponse2,
    NetworkService,
    NetworkServiceChangeRequest,
    NetworkServiceConfig,
    NetworkServiceConfigRequest,
    NetworkServiceConfigsGetResponse,
    NetworkServiceConfigsGetResponse1,
    NetworkServiceConfigsGetResponse2,
    NetworkServiceConfigsGetResponse3,
    NetworkServiceConfigsIdCancellationPolicyGetResponse,
    NetworkServiceConfigsIdCancellationPolicyGetResponse1,
    NetworkServiceConfigsIdCancellationPolicyGetResponse2,
    NetworkServiceConfigsIdDeleteResponse,
    NetworkServiceConfigsIdDeleteResponse1,
    NetworkServiceConfigsIdDeleteResponse2,
    NetworkServiceConfigsIdDeleteResponse3,
    NetworkServiceConfigsIdGetResponse,
    NetworkServiceConfigsIdGetResponse1,
    NetworkServiceConfigsIdGetResponse2,
    NetworkServiceConfigsIdPatchResponse,
    NetworkServiceConfigsIdPatchResponse1,
    NetworkServiceConfigsIdPatchResponse2,
    NetworkServiceConfigsIdPatchResponse3,
    NetworkServiceConfigsIdPutResponse,
    NetworkServiceConfigsIdPutResponse1,
    NetworkServiceConfigsIdPutResponse2,
    NetworkServiceConfigsIdPutResponse3,
    NetworkServiceConfigsPostResponse,
    NetworkServiceConfigsPostResponse1,
    NetworkServiceConfigsPostResponse2,
    NetworkServiceConfigUpdate,
    NetworkServiceConfigUpdatePartial,
    NetworkServiceRequest,
    NetworkServiceRequestPartial,
    NetworkServicesGetResponse,
    NetworkServicesGetResponse1,
    NetworkServicesGetResponse2,
    NetworkServicesGetResponse3,
    NetworkServicesIdCancellationPolicyGetResponse,
    NetworkServicesIdCancellationPolicyGetResponse1,
    NetworkServicesIdCancellationPolicyGetResponse2,
    NetworkServicesIdChangeRequestDeleteResponse,
    NetworkServicesIdChangeRequestDeleteResponse1,
    NetworkServicesIdChangeRequestDeleteResponse2,
    NetworkServicesIdChangeRequestDeleteResponse3,
    NetworkServicesIdChangeRequestGetResponse,
    NetworkServicesIdChangeRequestGetResponse1,
    NetworkServicesIdChangeRequestGetResponse2,
    NetworkServicesIdChangeRequestPostResponse,
    NetworkServicesIdChangeRequestPostResponse1,
    NetworkServicesIdChangeRequestPostResponse2,
    NetworkServicesIdDeleteResponse,
    NetworkServicesIdDeleteResponse1,
    NetworkServicesIdDeleteResponse2,
    NetworkServicesIdDeleteResponse3,
    NetworkServicesIdGetResponse,
    NetworkServicesIdGetResponse1,
    NetworkServicesIdGetResponse2,
    NetworkServicesIdPatchResponse,
    NetworkServicesIdPatchResponse1,
    NetworkServicesIdPatchResponse2,
    NetworkServicesIdPatchResponse3,
    NetworkServicesIdPutResponse,
    NetworkServicesIdPutResponse1,
    NetworkServicesIdPutResponse2,
    NetworkServicesIdPutResponse3,
    NetworkServicesPostResponse,
    NetworkServicesPostResponse1,
    NetworkServicesPostResponse2,
    PointOfPresence,
    PopsGetResponse,
    PopsGetResponse1,
    PopsGetResponse2,
    PopsGetResponse3,
    PopsIdGetResponse,
    PopsIdGetResponse1,
    PopsIdGetResponse2,
    Port,
    PortsGetResponse,
    PortsGetResponse1,
    PortsGetResponse2,
    PortsGetResponse3,
    PortsIdGetResponse,
    PortsIdGetResponse1,
    PortsIdGetResponse2,
    ProductOffering,
    ProductOfferingsGetResponse,
    ProductOfferingsGetResponse1,
    ProductOfferingsGetResponse2,
    ProductOfferingsGetResponse3,
    ProductOfferingsIdGetResponse,
    ProductOfferingsIdGetResponse1,
    ProductOfferingsIdGetResponse2,
    RefreshTokenRequest,
    Role3,
    RoleAssignment,
    RoleAssignmentRequest,
    RoleAssignmentsAssignmentIdDeleteResponse,
    RoleAssignmentsAssignmentIdDeleteResponse1,
    RoleAssignmentsAssignmentIdDeleteResponse2,
    RoleAssignmentsAssignmentIdDeleteResponse3,
    RoleAssignmentsAssignmentIdGetResponse,
    RoleAssignmentsAssignmentIdGetResponse1,
    RoleAssignmentsAssignmentIdGetResponse2,
    RoleAssignmentsGetResponse,
    RoleAssignmentsGetResponse1,
    RoleAssignmentsGetResponse2,
    RoleAssignmentsGetResponse3,
    RoleAssignmentsPostResponse,
    RoleAssignmentsPostResponse1,
    RoleAssignmentsPostResponse2,
    RolesGetResponse,
    RolesGetResponse1,
    RolesIdGetResponse,
    Type127,
    Type150,
    Type158,
    Type184,
    Type232,
    UpgradeAllowed,
)

app = MCPProxy(
    contact={'url': 'https://ix-api.net'},
    description='\nThis API allows to config/change/delete Internet Exchange services.\n\n# Filters\n\nWhen querying collections, the provided query parameters\nare validated. Unknown query parameters are ignored.\nProviding invalid filter values should yield a validation error.\n',
    title='IX-API',
    version='2.1.0',
    servers=[{'url': '/api/v2'}],
)


@app.get(
    '/accounts',
    description=""" Retrieve a list of `Account`s.

This includes all accounts the currently authorized account
is managing and the current account itself. """,
    tags=['user_account_management', 'user_role_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def accounts_list(
    id: Optional[Id] = None,
    state: Optional[str] = None,
    state__is_not: Optional[str] = None,
    managing_account: Optional[str] = None,
    billable: Optional[int] = None,
    external_ref: Optional[str] = None,
    name: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/accounts',
    description=""" Create a new account. """,
    tags=['user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def accounts_create(body: AccountRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/accounts/{id}',
    description=""" Accounts can be deleted, when all services and configs
are decommissioned or the account is not longer referenced
e.g. as a `managing_account` or `billing_account`.

Deleting an account will cascade to `contacts` and
`role-assignments`.

The request will immediately fail, if the above preconditions
are not met. """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def accounts_destroy(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/accounts/{id}',
    description=""" Get a single account. """,
    tags=['user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def accounts_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/accounts/{id}',
    description=""" Update parts of an account. """,
    tags=['user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def accounts_partial_update(id: str, body: AccountUpdatePartial = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/accounts/{id}',
    description=""" Update the entire account. """,
    tags=['user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def accounts_update(id: str, body: AccountUpdate = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/auth/refresh',
    description=""" Reauthenticate the API user, issue a new `access_token`
and `refresh_token` pair by providing the `refresh_token`
in the request body. """,
    tags=['authentication_management'],
)
def auth_token_refresh(body: RefreshTokenRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/auth/token',
    description=""" Authenticate an API user identified by `api_key` and
`api_secret`. """,
    tags=['authentication_management'],
)
def auth_token_create(body: AuthTokenRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/connections',
    description=""" List all `connection`s. """,
    tags=[
        'network_pop_management',
        'metro_area_network_overview',
        'facility_details_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def connections_list(
    id: Optional[Id] = None,
    state: Optional[str] = None,
    state__is_not: Optional[str] = None,
    mode: Optional[str] = None,
    mode__is_not: Optional[str] = None,
    name: Optional[str] = None,
    metro_area_network: Optional[str] = None,
    pop: Optional[str] = None,
    facility: Optional[str] = None,
    external_ref: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/connections/{id}',
    description=""" Read a `connection`. """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def connections_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contacts',
    description=""" List available contacts managed by the authorized account. """,
    tags=['user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def contacts_list(
    id: Optional[Id] = None,
    managing_account: Optional[str] = None,
    consuming_account: Optional[str] = None,
    external_ref: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/contacts',
    description=""" Create a new contact. """,
    tags=['contact_information_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def contacts_create(body: ContactRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/contacts/{id}',
    description=""" Remove a contact.

Please note, that a contact can only be removed if
it is not longer in use in a network service or config
through a role assignment. """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def contacts_destroy(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contacts/{id}',
    description=""" Get a contact by it's id """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def contacts_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/contacts/{id}',
    description=""" Update parts of a contact """,
    tags=['contact_information_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def contacts_partial_update(id: str, body: ContactRequestPartial = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/contacts/{id}',
    description=""" Update a contact """,
    tags=['contact_information_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def contacts_update(id: str, body: ContactRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/devices',
    description=""" List available devices """,
    tags=[
        'network_ports_overview',
        'network_feature_configuration_management',
        'network_service_operations',
        'network_pop_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def devices_list(
    id: Optional[Id] = None,
    name: Optional[str] = None,
    capability_media_type: Optional[str] = None,
    capability_speed: Optional[int] = None,
    capability_speed__lt: Optional[int] = None,
    capability_speed__lte: Optional[int] = None,
    capability_speed__gt: Optional[int] = None,
    capability_speed__gte: Optional[int] = None,
    facility: Optional[str] = None,
    pop: Optional[str] = None,
    metro_area_network: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/devices/{id}',
    description=""" Get a specific device identified by id """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def devices_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/facilities',
    description=""" Get a (filtered) list of `facilities`. """,
    tags=[
        'network_connection_management',
        'metro_area_network_overview',
        'network_ports_overview',
        'network_feature_configuration_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def facilities_list(
    id: Optional[Id] = None,
    capability_media_type: Optional[str] = None,
    capability_speed: Optional[int] = None,
    capability_speed__lt: Optional[int] = None,
    capability_speed__lte: Optional[int] = None,
    capability_speed__gt: Optional[int] = None,
    capability_speed__gte: Optional[int] = None,
    organisation_name: Optional[str] = None,
    metro_area: Optional[str] = None,
    metro_area_network: Optional[str] = None,
    address_country: Optional[str] = None,
    address_locality: Optional[str] = None,
    postal_code: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/facilities/{id}',
    description=""" Retrieve a facility by id """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def facilities_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/health',
    description=""" Get the IX-API service health status. """,
    tags=[
        'user_account_management',
        'authentication_management',
        'user_role_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def api_health_read():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/implementation',
    description=""" Get the API implementation details. """,
    tags=[
        'user_account_management',
        'authentication_management',
        'user_role_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def api_implementation_read():
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ips',
    description=""" List all ip addresses (and prefixes). """,
    tags=[
        'network_service_operations',
        'network_feature_configuration_management',
        'ip_address_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def ips_list(
    id: Optional[Id] = None,
    managing_account: Optional[str] = None,
    consuming_account: Optional[str] = None,
    external_ref: Optional[str] = None,
    network_service: Optional[str] = None,
    network_service_config: Optional[str] = None,
    network_feature: Optional[str] = None,
    network_feature_config: Optional[str] = None,
    version: Optional[int] = None,
    fqdn: Optional[str] = None,
    prefix_length: Optional[int] = None,
    valid_not_before: Optional[str] = None,
    valid_not_after: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ips',
    description=""" Add an ip host address or network prefix. """,
    tags=['ip_address_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def ips_create(body: IpAddressRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ips/{id}',
    description=""" Get a single ip addresses by it's id. """,
    tags=['user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def ips_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/ips/{id}',
    description=""" Update parts of an ip address.


As with the `PUT` opertaion, IP addresses, where you
don't have update rights, will yield a `resource access denied`
error when attempting an update.

If the ip address was allocated for you, you might
not be able to change anything but the `fqdn`. """,
    tags=['ip_address_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def ips_partial_update(id: str, body: IpAddressUpdatePartial = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/ips/{id}',
    description=""" Update an ip address object.

You can only update
IP addresses within your current scope. Not all
addresses you can read you can update.

If the ip address was allocated for you, you might
not be able to change anything but the `fqdn`. """,
    tags=['ip_address_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def ips_update(id: str, body: IpAddressUpdate = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/macs',
    description=""" List all mac addresses managed by the authorized customer. """,
    tags=[
        'network_service_operations',
        'ip_address_management',
        'network_feature_configuration_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def macs_list(
    id: Optional[Id] = None,
    managing_account: Optional[str] = None,
    consuming_account: Optional[str] = None,
    external_ref: Optional[str] = None,
    network_service_config: Optional[str] = None,
    address: Optional[str] = None,
    assigned_at: Optional[str] = None,
    valid_not_before: Optional[str] = None,
    valid_not_after: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/macs',
    description=""" Register a mac address. """,
    tags=['mac_address_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def macs_create(body: MacAddressRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/macs/{id}',
    description=""" Remove a mac address. """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def macs_destroy(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/macs/{id}',
    description=""" Get a single mac address by it's id. """,
    tags=['user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def macs_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/member-joining-rules',
    description=""" Get a list of joining rules """,
    tags=['network_service_operations', 'network_connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def member_joining_rules_list(
    id: Optional[Id] = None, network_service: Optional[str] = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/member-joining-rules',
    description=""" Create a member joining rule """,
    tags=['member_joining_rules_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def member_joining_rules_create(body: MemberJoiningRuleRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/member-joining-rules/{id}',
    description=""" Delete a joining rule """,
    tags=['user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def member_joining_rules_destroy(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/member-joining-rules/{id}',
    description=""" Get a single rule """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def member_joining_rules_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/member-joining-rules/{id}',
    description=""" Partially update a joining rule """,
    tags=['member_joining_rules_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def member_joining_rules_partial_update(
    id: str, body: MemberJoiningRuleUpdatePartial = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/member-joining-rules/{id}',
    description=""" Update a joining rule """,
    tags=['member_joining_rules_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def member_joining_rules_update(id: str, body: MemberJoiningRuleUpdate = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/metro-area-networks',
    description=""" List all MetroAreaNetworks """,
    tags=[
        'facility_details_management',
        'metro_area_network_overview',
        'network_service_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def metro_area_networks_list(
    id: Optional[Id] = None,
    name: Optional[str] = None,
    metro_area: Optional[str] = None,
    service_provider: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/metro-area-networks/{id}',
    description=""" Retrieve a MetroAreaNetwork """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def metro_area_networks_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/metro-areas',
    description=""" List all MetroAreas """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def metro_areas_list(id: Optional[Id] = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/metro-areas/{id}',
    description=""" Get a single MetroArea """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def metro_areas_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/network-feature-configs',
    description=""" Get all network feature configs. """,
    tags=['network_feature_configuration_management', 'network_service_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_feature_configs_list(
    id: Optional[Id] = None,
    state: Optional[str] = None,
    state__is_not: Optional[str] = None,
    managing_account: Optional[str] = None,
    consuming_account: Optional[str] = None,
    external_ref: Optional[str] = None,
    type: Optional[Type127] = None,
    service_config: Optional[str] = None,
    network_feature: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/network-feature-configs',
    description=""" Create a configuration for a `NetworkFeature`
defined in the `NetworkFeature`s collection. """,
    tags=['network_feature_configuration_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_feature_configs_create(body: NetworkFeatureConfigRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/network-feature-configs/{id}',
    description=""" Remove a network feature config.

The network feature config will be marked as
`decommission_requested`.
Decommissioning a network feature config will not
cascade to related services or service configs. """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_feature_configs_destroy(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/network-feature-configs/{id}',
    description=""" Get a single network feature config. """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_feature_configs_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/network-feature-configs/{id}',
    description=""" Update parts of a network feature configuration """,
    tags=['network_feature_configuration_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_feature_configs_partial_update(
    id: str, body: NetworkFeatureConfigUpdatePartial = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/network-feature-configs/{id}',
    description=""" Update a network feature configuration """,
    tags=['network_feature_configuration_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_feature_configs_update(id: str, body: NetworkFeatureConfigUpdate = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/network-features',
    description=""" List available network features. """,
    tags=['network_service_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_features_list(
    id: Optional[Id] = None,
    type: Optional[Type150] = None,
    required: Optional[str] = None,
    network_service: Optional[str] = None,
    name: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/network-features/{id}',
    description=""" Get a single network feature by it's id. """,
    tags=['user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_features_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/network-service-configs',
    description=""" Get all `network-service-config`s. """,
    tags=[
        'network_connection_management',
        'network_service_operations',
        'product_offering_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_service_configs_list(
    id: Optional[Id] = None,
    state: Optional[str] = None,
    state__is_not: Optional[str] = None,
    managing_account: Optional[str] = None,
    consuming_account: Optional[str] = None,
    external_ref: Optional[str] = None,
    type: Optional[Type158] = None,
    inner_vlan: Optional[int] = None,
    outer_vlan: Optional[int] = None,
    capacity: Optional[int] = None,
    network_service: Optional[str] = None,
    connection: Optional[str] = None,
    product_offering: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/network-service-configs',
    description=""" Create a `network-service-config`. """,
    tags=['network_service_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_service_configs_create(body: NetworkServiceConfigRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/network-service-configs/{id}',
    description=""" Request decommissioning the network service configuration.

The network service config will assume the state
`decommission_requested`.
This will cascade to related resources like
`network-feature-configs`. """,
    tags=['network_service_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_service_configs_destroy(id: str, body: CancellationRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/network-service-configs/{id}',
    description=""" Get a `network-service-config` """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_service_configs_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/network-service-configs/{id}',
    description=""" Update parts of an exisiting `network-service-config`. """,
    tags=['network_service_operations', 'network_feature_configuration_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_service_configs_partial_update(
    id: str, body: NetworkServiceConfigUpdatePartial = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/network-service-configs/{id}',
    description=""" Update an exisiting `network-service-config` """,
    tags=['network_service_operations', 'network_feature_configuration_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_service_configs_update(id: str, body: NetworkServiceConfigUpdate = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/network-service-configs/{id}/cancellation-policy',
    description=""" The cancellation-policy can be queried to answer
the questions:

If I cancel my subscription, *when will it be technically
decommissioned*?
If I cancel my subscription, *until what date will I be charged*?

When the query parameter `decommision_at` is not provided
it will provide the first possible cancellation date
and charge period if cancelled at above date.

The granularity of the date field is a day, the start and end
of which are to be interpreted by the IXP (some may use UTC,
some may use their local time zone). """,
    tags=['user_account_management', 'user_role_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_service_config_cancellation_policy_read(
    id: str, decommission_at: Optional[str] = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/network-services',
    description=""" List available `NetworkService`s. """,
    tags=['product_offering_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_services_list(
    id: Optional[Id] = None,
    state: Optional[str] = None,
    state__is_not: Optional[str] = None,
    managing_account: Optional[str] = None,
    consuming_account: Optional[str] = None,
    external_ref: Optional[str] = None,
    type: Optional[Type184] = None,
    pop: Optional[str] = None,
    product_offering: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/network-services',
    description=""" Create a new network service """,
    tags=['network_service_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_services_create(body: NetworkServiceRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/network-services/{id}',
    description=""" Request decomissioning of the network service.

The network service will enter the state of
`decommission_requested`. The request will
cascade to related network service and feature
configs.

An *optional request body* can be provided to request
a specific service termination date.

If no date is given in the request body, it is assumed to
be the earliest possible date.

Possible values for `decommission_at` can be queried
through the `network_service_cancellation_policy_read`
operation.

The response will contain the dates on which the
changes will be effected. """,
    tags=['network_service_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_services_destroy(id: str, body: CancellationRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/network-services/{id}',
    description=""" Get a specific `network-service` by id. """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_services_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/network-services/{id}',
    description=""" Partially update a network service """,
    tags=['network_service_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_services_partial_update(id: str, body: NetworkServiceRequestPartial = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/network-services/{id}',
    description=""" Update a network service """,
    tags=['network_service_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_services_update(id: str, body: NetworkServiceRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/network-services/{id}/cancellation-policy',
    description=""" The cancellation-policy can be queried to answer
the questions:

If I cancel my service, *when will it be technically
decommissioned*?
If I cancel my service, *until what date will I be charged*?

When the query parameter `decommision_at` is not provided
it will provide the first possible cancellation date
and charge period if cancelled at above date.

The granularity of the date field is a day, the start and end
of which are to be interpreted by the IXP (some may use UTC,
some may use their local time zone). """,
    tags=['user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_service_cancellation_policy_read(
    id: str, decommission_at: Optional[str] = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/network-services/{id}/change-request',
    description=""" Retract or reject a change to the network service. """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_service_change_request_destroy(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/network-services/{id}/change-request',
    description=""" Get the change request. """,
    tags=['user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_service_change_request_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/network-services/{id}/change-request',
    description=""" Request a change to the network service.

A participant in a network service of type
`p2p_vc` can issue a change request, expressing a
desired change in the capacity.
The change is accepted when all sides have configured
the network service configs with the new bandwidth.
These changes can sometimes require a change of the
product offering.
The product offering may only differ in regards to
bandwidth.

The network service will change it's state from `production`
into `production_change_pending`.

Only one change request may be issued at a time. """,
    tags=['network_service_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def network_service_change_request_create(
    id: str, body: NetworkServiceChangeRequest = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/pops',
    description=""" List all PoPs """,
    tags=[
        'network_connection_management',
        'metro_area_network_overview',
        'network_ports_overview',
        'facility_details_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def pops_list(
    id: Optional[Id] = None,
    facility: Optional[str] = None,
    metro_area_network: Optional[str] = None,
    capability_media_type: Optional[str] = None,
    capability_speed: Optional[int] = None,
    capability_speed__lt: Optional[int] = None,
    capability_speed__lte: Optional[int] = None,
    capability_speed__gt: Optional[int] = None,
    capability_speed__gte: Optional[int] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/pops/{id}',
    description=""" Get a single point of presence """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def pops_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ports',
    description=""" List all ports. """,
    tags=[
        'network_connection_management',
        'device_information_management',
        'network_pop_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def ports_list(
    id: Optional[Id] = None,
    state: Optional[str] = None,
    state__is_not: Optional[str] = None,
    media_type: Optional[str] = None,
    pop: Optional[str] = None,
    name: Optional[str] = None,
    external_ref: Optional[str] = None,
    device: Optional[str] = None,
    speed: Optional[str] = None,
    connection: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ports/{id}',
    description=""" Retrieve a port. """,
    tags=['user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def ports_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/product-offerings',
    description=""" List all (filtered) products-offerings available on the platform """,
    tags=[
        'network_service_operations',
        'metro_area_network_overview',
        'network_ports_overview',
        'product_offering_management',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def product_offerings_list(
    id: Optional[Id] = None,
    type: Optional[Type232] = None,
    name: Optional[str] = None,
    handover_metro_area: Optional[str] = None,
    handover_metro_area_network: Optional[str] = None,
    service_metro_area: Optional[str] = None,
    service_metro_area_network: Optional[str] = None,
    service_provider: Optional[str] = None,
    downgrade_allowed: Optional[DowngradeAllowed] = None,
    upgrade_allowed: Optional[UpgradeAllowed] = None,
    bandwidth: Optional[int] = None,
    physical_port_speed: Optional[int] = None,
    service_provider_region: Optional[str] = None,
    service_provider_pop: Optional[str] = None,
    delivery_method: Optional[DeliveryMethod] = None,
    cloud_key: Optional[str] = None,
    fields: Optional[str] = None,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/product-offerings/{id}',
    description=""" Get a single products-offering by id. """,
    tags=['user_account_management', 'authentication_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def product_offerings_read(id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/role-assignments',
    description=""" List all role assignments for a contact. """,
    tags=['contact_information_management', 'user_role_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def role_assignments_list(
    id: Optional[Id] = None, contact: Optional[str] = None, role: Optional[str] = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/role-assignments',
    description=""" Assign a `Role` to a `Contact`.

The contact needs to have all fields filled, which the
role requires. If this is not the case a `400`
`UnableToFulfill` will be returned. """,
    tags=['user_role_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def role_assignments_create(body: RoleAssignmentRequest = None):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/role-assignments/{assignment_id}',
    description=""" Remove a role assignment from a contact.

If the contact is still in use with a given role required,
this will yield an `UnableToFulfill` error. """,
    tags=['user_role_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def role_assignments_destroy(assignment_id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/role-assignments/{assignment_id}',
    description=""" Get a role assignment for a contact. """,
    tags=['user_role_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def role_assignments_read(assignment_id: str):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/roles',
    description=""" List all roles available. """,
    tags=['contact_information_management', 'user_account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def roles_list(
    id: Optional[Id] = None, name: Optional[str] = None, contact: Optional[str] = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/roles/{id}',
    description=""" Get a single `Role`. """,
    tags=['user_account_management', 'user_role_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def roles_read(
    id: Union[str, Optional[Id], Optional[Id], Optional[Id]], name: Optional[str] = None
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
